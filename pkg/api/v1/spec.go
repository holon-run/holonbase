package v1

import (
	"encoding/json"
	"fmt"
)

// HolonSpec defines the standardized task execution unit.
type HolonSpec struct {
	Version     string           `yaml:"version" json:"version"`
	Kind        string           `yaml:"kind" json:"kind"`
	Metadata    Metadata         `yaml:"metadata" json:"metadata"`
	Context     Context          `yaml:"context" json:"context"`
	Goal        Goal             `yaml:"goal" json:"goal"`
	Output      Output           `yaml:"output" json:"output"`
	Constraints Constraints      `yaml:"constraints" json:"constraints"`
}

type Metadata struct {
	Name   string   `yaml:"name" json:"name"`
	ID     string   `yaml:"id,omitempty" json:"id,omitempty"`
	Skills []string `yaml:"skills,omitempty" json:"skills,omitempty"`
}

type Context struct {
	Workspace string            `yaml:"workspace" json:"workspace"`
	Files     []string          `yaml:"files,omitempty" json:"files,omitempty"`
	Env       map[string]string `yaml:"env,omitempty" json:"env,omitempty"`
}

type Goal struct {
	Description string `yaml:"description" json:"description"`
	IssueID     string `yaml:"issue_id,omitempty" json:"issue_id,omitempty"`
}

type Output struct {
	Artifacts []Artifact `yaml:"artifacts" json:"artifacts"`
}

type Artifact struct {
	Path     string `yaml:"path" json:"path"`
	Required bool   `yaml:"required" json:"required"`
}

type Constraints struct {
	Timeout  string `yaml:"timeout,omitempty" json:"timeout,omitempty"`
	MaxSteps int    `yaml:"max_steps,omitempty" json:"max_steps,omitempty"`
}

// HolonManifest is generated by the agent at the end of execution.
type HolonManifest struct {
	Status    string                 `json:"status"`
	Outcome   string                 `json:"outcome"` // success, failure, needs_human
	Duration  Duration               `json:"duration"`
	Artifacts Artifacts              `json:"artifacts"`
	Metadata  map[string]interface{} `json:"metadata,omitempty"`
}

// ManifestArtifact represents a single artifact entry in a manifest (generated by agent)
type ManifestArtifact struct {
	Name string `json:"name"`
	Path string `json:"path"`
}

// Artifacts is a slice type that can unmarshal from both string arrays and object arrays
type Artifacts []string

// UnmarshalJSON implements json.Unmarshaler for Artifacts
// It accepts both string arrays and object arrays (for backward compatibility)
func (a *Artifacts) UnmarshalJSON(data []byte) error {
	// Try to unmarshal as string array first
	var strs []string
	if err := json.Unmarshal(data, &strs); err == nil {
		*a = strs
		return nil
	}

	// Try to unmarshal as object array (backward compatibility with old agent bundles)
	var objs []ManifestArtifact
	if err := json.Unmarshal(data, &objs); err == nil {
		result := make([]string, len(objs))
		for i, obj := range objs {
			result[i] = obj.Path
		}
		*a = result
		return nil
	}

	return fmt.Errorf("cannot unmarshal artifacts: %s", string(data))
}

// MarshalJSON implements json.Marshaler for Artifacts
func (a Artifacts) MarshalJSON() ([]byte, error) {
	return json.Marshal([]string(a))
}

// Duration is a string type that can also unmarshal from a number (for backward compatibility)
type Duration string

// UnmarshalJSON implements json.Unmarshaler for Duration
// It accepts both string ("1.5s") and number (1.5) formats
func (d *Duration) UnmarshalJSON(data []byte) error {
	// Try to unmarshal as string first
	var s string
	if err := json.Unmarshal(data, &s); err == nil {
		*d = Duration(s)
		return nil
	}

	// Try to unmarshal as number (backward compatibility with old agent bundles)
	var f float64
	if err := json.Unmarshal(data, &f); err == nil {
		*d = Duration(fmt.Sprintf("%.1fs", f))
		return nil
	}

	return fmt.Errorf("cannot unmarshal %s into Duration", string(data))
}

// MarshalJSON implements json.Marshaler for Duration
func (d Duration) MarshalJSON() ([]byte, error) {
	return json.Marshal(string(d))
}

// String returns the string representation of the duration
func (d Duration) String() string {
	return string(d)
}
